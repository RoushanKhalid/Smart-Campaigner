# -*- coding: utf-8 -*-
"""Smart Campaigner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m-c5wEj1_w2ftiAylhTLVgq4bSWSr0wg
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.cluster import KMeans
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler

dataset = pd.read_csv("/content/synthetic_swopno_transactions_200.csv")

dataset.head()

dataset.dtypes

dataset['InvoiceDate'] = pd.to_datetime(dataset['InvoiceDate'])

dataset.dtypes

current_date = pd.to_datetime('2026-01-01')
current_date

dataset.head()

max_date = dataset.groupby(["CustomerID"]).max()[['InvoiceDate']]
max_date # latest of each customer

max_date['InvoiceAge'] = (current_date - max_date['InvoiceDate']).dt.days
max_date

print(max_date['InvoiceAge'].min(),"days")
print(max_date['InvoiceAge'].max(),"days")
print("Duration:", max_date['InvoiceAge'].max() - max_date['InvoiceAge'].min(),"days")

#recenccy
recency = max_date.drop('InvoiceDate', axis=1)
recency

#frequency
freq = dataset.drop_duplicates(subset="InvoiceNo")
freq

freq = freq.groupby(["CustomerID"]).count()[["InvoiceNo"]]
freq # calculating the purchase frequency of each customer

freq['InvoiceNo'].max()

freq['InvoiceNo'].min()

dataset["Total_in_BDT"]=dataset["Quantity"] * dataset["UnitPrice"]
dataset

#monetary
money=dataset.groupby(["CustomerID"])[["Total_in_BDT"]].sum()
money

RFM = pd.concat([recency,freq,money], axis=1)
RFM

RFM.columns = ['Recency', 'Frequency', 'Monetary']
RFM

scaler = StandardScaler()
scaled = scaler.fit_transform(RFM)

scaled.shape

# Define a range of possible cluster numbers (k) to try
k_range = range(2, 11)

# Create an empty list to store the Sum of Squared Errors (SSE) for each k
sse = []

# Loop through each value of k in the defined range
for k in k_range:
    # Initialize the KMeans model with the current number of clusters (k)
    km = KMeans(n_clusters=k, random_state=42, n_init=10) # Added random_state and n_init for reproducibility

    # Fit the KMeans model to the scaled data
    km.fit(scaled)

    # Append the calculated SSE (inertia_) for the current k to the sse list
    sse.append(km.inertia_)

# The 'sse' list now contains the SSE values for each tested k.
# This list is often used to create an "elbow plot" to visually identify the optimal k.

plt.plot(k_range, sse, 'r-*')
plt.xlabel ='k'
plt.ylabel = 'Sum of Squared Error'

!pip install yellowbrick

from yellowbrick.cluster import KElbowVisualizer
Elbow = KElbowVisualizer(KMeans(), k=10)
Elbow.fit(scaled)
Elbow.show()

kmeans=KMeans(n_clusters=4)
kmeans.fit(scaled)

kmeans.labels_

kmeans.labels_.shape

RFM["Clusters"]=(kmeans.labels_)
RFM

RFM.Clusters.unique()

fig = plt.figure(figsize=(10,8))
ax = plt.subplot(111, projection='3d', label="bla")
ax.scatter(RFM["Recency"],RFM["Frequency"],RFM["Monetary"], s=40, c=RFM["Clusters"], marker='o', cmap = "Accent")
ax.set_title("The Plot Of The Clusters")
plt.show()

RFM[RFM.Clusters==0]

RFM[RFM.Clusters==1]

RFM[RFM.Clusters==2]

RFM[RFM.Clusters==3]

final=RFM.groupby("Clusters").mean()[["Recency","Frequency","Monetary"]]
final

def func(row):
  if row["Clusters"]==0:
    return "Bronze"
  elif row["Clusters"]==1:
    return "Silver"
  elif row["Clusters"]==2:
    return "Gold"
  else:
    return "Platinum"

RFM['Group']=RFM.apply(func, axis=1)
RFM

result = pd.DataFrame(RFM.Group.value_counts())
result

result = result.sort_values(by='count', ascending=False)
datalabel = sns.barplot(x="Group", y="count", data=result, estimator=np.sum)
for i in datalabel.containers:
    datalabel.bar_label(i,)

RFM

bronze_customers = RFM[RFM['Group'] == 'Bronze']
bronze_contact_info = pd.merge(bronze_customers, dataset[['CustomerID', 'Location','CustomerPhoneNo', 'Email']], on='CustomerID', how='left')
display(bronze_contact_info[['CustomerID', 'Location', 'CustomerPhoneNo', 'Email']])

silver_customers = RFM[RFM['Group'] == 'Silver']
silver_contact_info = pd.merge(silver_customers, dataset[['CustomerID', 'Location','CustomerPhoneNo', 'Email']], on='CustomerID', how='left')
display(silver_contact_info[['CustomerID', 'Location','CustomerPhoneNo', 'Email']])

gold_customers = RFM[RFM['Group'] == 'Gold']
gold_contact_info = pd.merge(gold_customers, dataset[['CustomerID', 'Location','CustomerPhoneNo', 'Email']], on='CustomerID', how='left')
display(gold_contact_info[['CustomerID', 'Location','CustomerPhoneNo', 'Email']])

platinum_customers = RFM[RFM['Group'] == 'Platinum']
platinum_contact_info = pd.merge(platinum_customers, dataset[['CustomerID', 'Location', 'CustomerPhoneNo', 'Email']], on='CustomerID', how='left')
display(platinum_contact_info[['CustomerID','Location', 'CustomerPhoneNo', 'Email']])

# Save contact information for each group to CSV files

if 'bronze_contact_info' in locals():
    bronze_contact_info[['CustomerID', 'Location', 'CustomerPhoneNo', 'Email']].to_csv('bronze_contact_info.csv', index=False)
    print("Saved bronze_contact_info.csv")
else:
    print("bronze_contact_info DataFrame not found.")

if 'silver_contact_info' in locals():
    silver_contact_info[['CustomerID', 'Location', 'CustomerPhoneNo', 'Email']].to_csv('silver_contact_info.csv', index=False)
    print("Saved silver_contact_info.csv")
else:
    print("silver_contact_info DataFrame not found.")

if 'gold_contact_info' in locals():
    gold_contact_info[['CustomerID', 'Location', 'CustomerPhoneNo', 'Email']].to_csv('gold_contact_info.csv', index=False)
    print("Saved gold_contact_info.csv")
else:
    print("gold_contact_info DataFrame not found.")

if 'platinum_contact_info' in locals():
    platinum_contact_info[['CustomerID', 'Location', 'CustomerPhoneNo', 'Email']].to_csv('platinum_contact_info.csv', index=False)
    print("Saved platinum_contact_info.csv")
else:
    print("platinum_contact_info DataFrame not found.")

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import pandas as pd
# Used to securely store your API key
from google.colab import userdata


# -------------------------------------------
# ‚úâÔ∏è SMTP Configuration (edit only these two lines)
# -------------------------------------------
sender_email = input("Enter your sender email: ").strip()
# Access password securely using Colab Secrets Manager
sender_password = userdata.get('GMAIL_APP_PASSWORD')

SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587

# -------------------------------------------
# üì© Function: Send Single Email
# -------------------------------------------
def send_campaign_email(recipient_email, subject, body):
    """
    Sends a single campaign email to a recipient.

    Parameters:
        recipient_email (str): The email address of the recipient.
        subject (str): The subject line of the email.
        body (str): The plain-text message body to send.

    Returns:
        None. Prints success or failure messages to the console.
    """
    try:
        # Create the email message
        message = MIMEMultipart()
        message["From"] = sender_email
        message["To"] = recipient_email
        message["Subject"] = subject
        message.attach(MIMEText(body, "plain"))

        # Connect to the SMTP server and send the message
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls()  # Secure the connection
            server.login(sender_email, sender_password)
            server.send_message(message)

        print(f"‚úÖ Email sent successfully to {recipient_email}")

    except Exception as e:
        print(f"‚ùå Failed to send email to {recipient_email}: {e}")

# -------------------------------------------
# üéØ Campaign Details per Customer Segment
# -------------------------------------------
campaign_groups_contact = {
    'Bronze': {
        'filename': 'bronze_contact_info.csv',
        'subject': 'A Special Offer for You!',
        'message': "We‚Äôve missed you! Enjoy up to 50% off ‚Äî just for coming back."
    },
    'Silver': {
        'filename': 'silver_contact_info.csv',
        'subject': 'Your Exclusive Silver Offer!',
        'message': "Your exclusive comeback offer: up to 35% off."
    },
    'Gold': {
        'filename': 'gold_contact_info.csv',
        'subject': 'Gold Perks Just For You!',
        'message': "Gold perks unlocked! Get your exclusive 25% comeback deal!"
    },
    'Platinum': {
        'filename': 'platinum_contact_info.csv',
        'subject': 'Thank You, Platinum Customer!',
        'message': "Platinum members only: Enjoy 10% off at any brunch spot."
    }
}

# -------------------------------------------
# üöÄ Main Loop: Read Contacts & Send Emails
# -------------------------------------------
for group_name, group_info in campaign_groups_contact.items():
    try:
        contact_df = pd.read_csv(group_info['filename'])

        if 'Email' in contact_df.columns and 'CustomerID' in contact_df.columns:
            print(f"\nüì¢ Sending emails to {group_name} customers...")
            for _, row in contact_df.iterrows():
                customer_id = row['CustomerID']
                customer_email = row['Email']

                subject = group_info['subject']
                body = f"Dear {customer_id},\n\n{group_info['message']}\n\nBest Regards,\nSwopno Customer Care Team"

                send_campaign_email(customer_email, subject, body)

        else:
            print(f"‚ö†Ô∏è Skipping {group_name} group: Missing 'Email' or 'CustomerID' column in {group_info['filename']}")

    except FileNotFoundError:
        print(f"üö´ Skipping {group_name} group: {group_info['filename']} not found.")
    except Exception as e:
        print(f"‚ùå An error occurred while processing {group_name} group: {e}")